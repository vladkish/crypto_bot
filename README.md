## Elsa

### описание
софт для взаимодействия с AI [Elsa](https://app.heyelsa.ai/)  
выполняет свапы в Base, бриджи из/в Base, минт NFT от Elsa (*то есть все, что требуется для квестов*)  
все действия выполняются в рандомном порядке, в том числе свапы в обе стороны (*подробнее далее*)

*о логике свапов*  
после свапа из ETH в токен, обратный свап из токена в ETH происходит не сразу, а в рандомный момент, например 
после нескольких кошельков, пример:   
`кошелек1: ETH → USDC`  
`кошелек3: ETH → AAVE`  
`кошелек1: USDC → ETH`  
`кошелек2: ETH → ENA`  
`кошелек3: AAVE → ETH`  
`кошелек2: ENA → ETH`  
так же имеется возможность продавать токен не сразу после его покупки, а сначала купить еще токен (или несколько), 
а только потом продавать какой-либо токен.  
более подробно описано в настройке `SWAP_SETTINGS["max_token_hold"]` и рассказано в видеоинструкции к этому софту

*о шаблонах для промптов (сообщения которые отправляются ИИшке)*  
промпты для свапов указываются в файле `input_data/swap_prompts.txt`, можно оставить значения по дефолту.  
должно быть минимум по одному промпту для каждого вида свапов:
 
1. промпт для свапа **из ETH в любой токен**, где количество ETH указывается в $, в нем должны содержаться 
следующие значения:  
   * `{usd_amount}` - количество ETH в долларах, которое будет свапаться в другой токен
   * `{from_token}` - токен из которого будет происходить свап, обычно ETH
   * `{to_token}` - токен в который будет происходить свап, любой из настроек
   * `{chain_name}` - название сети в которой будет происходить свап

   если использовать готовый шаблон из файла  
   `swap {usd_amount}$ in {from_token} to {to_token} in {chain_name}`  
   то примерный вопрос ИИшке будет выглядеть:  
   `swap 15.8$ in ETH to USDC in base`


2. промпт для свапа **из токена в ETH**, где количество токена указывается именно в токене (а не в $), в нем должны 
содержаться следующие значения:  
   * `{token_amount}` - количество токена, которое будет свапаться в ETH
   * `{from_token}` - токен из которого будет происходить свап, обычно ETH
   * `{to_token}` - токен в который будет происходить свап, любой из настроек
   * `{chain_name}` - название сети в которой будет происходить свап

   если использовать готовый шаблон из файла  
   `swap {token_amount} {from_token} to {to_token} in {chain_name}`  
   то примерный вопрос ИИшке будет выглядеть:  
   `swap 8.5 USDC to ETH in base`


тот же принцип и с промптами для бриджа, указываются в `input_data/bridge_prompts.txt`  
у этих промптов так же 2 вида, необходимые значения:
1. * `{usd_amount}` - количество ETH в долларах, которое будет бриджиться
   * `{from_chain}` - из какой сети бриджить
   * `{to_chain}` - в какую сеть бриджить  

   если использовать готовый шаблон из файла  
   `bridge {usd_amount}$ in ETH from {from_chain} to {to_chain}`  
   то примерный вопрос ИИшке будет выглядеть:  
   `bridge 15$ in ETH from base to linea`


2. * `{token_amount}` - количество ETH, которое будет бриджиться
   * `{from_chain}` - из какой сети бриджить
   * `{to_chain}` - в какую сеть бриджить  

   если использовать готовый шаблон из файла  
   `bridge {token_amount} ETH from {from_chain} to {to_chain}`  
   то примерный вопрос ИИшке будет выглядеть:  
   `bridge 0.01 ETH from linea to base`

*о бриджах*  
для выполнения ежедневного квеста с бриджем (*квест требует бриджа именно в Base*) софт всегда бриджит из Base в 
рандомную сеть и из этой сети обратно в Base.  
проверка баланса в разных сетях и бридж сразу из рандомной сети в Base (*что бы бриджить только один раз*) специально 
не реализована, потому что через несколько таких выполнений этого квеста балансы ETH c разных сетях стекут в Base


---

### настройка

1. в папке `input_data`:
   1) заполнить приватники в `privatekeys.txt`
   2) при необходимости добавить прокси в `proxies.txt` (используется для RPC, на случай если запускаете во
много потоков)
2. в `settings.py` настройте софт под себя

---

### запуск

1. установить необходимые либы `pip install -r requirements.txt`
2. запустить софт `py main.py`
3. создать базу данных (*Create Database → New Database*)
4. стартуем необходимый режим
